{"ast":null,"code":"// We need to enable JavaScript Built-in BigInt\n/* global BigInt */ // this number can be tweaked to achieve more efficient calculations\n// but should be carefully selected to prevent filling JS maximum heap size\nexport var MAXIMUM_ARRAY_LENGTH_FOR_MEMOIZATION=10000;// we use BigInt for bigger precision\nexport var initialCache=[BigInt(0),BigInt(1),BigInt(1)];// we make a copy to prevent modifying the original cache\nexport var fibonacciCache=[].concat(initialCache);export function cleanFibonacciCache(){fibonacciCache=[].concat(initialCache);}//export function FibonacciRecursive(naturalNumber) {\n//  // memoized version of Fibonacci succession\n//  // for big numbers fails because stack size is exceeded\n//  if (fibonacciCache[naturalNumber]) {\n//    return fibonacciCache[naturalNumber];\n//  }\n//  fibonacciCache[naturalNumber] =\n//    FibonacciRecursive(naturalNumber - 1) +\n//    FibonacciRecursive(naturalNumber - 2);\n//  return fibonacciCache[naturalNumber];\n//}\nexport function FibonacciIterativeMemoized(naturalNumber){// iterative version of Fibonacci with memoization\nif(!(fibonacciCache[naturalNumber]===undefined)){return fibonacciCache[naturalNumber];}var N=fibonacciCache.length;for(var i=N;i<=naturalNumber;i++){var calc=fibonacciCache[i-1]+fibonacciCache[i-2];fibonacciCache[i]=calc;}return fibonacciCache[naturalNumber];}export function FibonacciIterative(naturalNumber){// iterative version of Fibonacci using already done calculations\nif(!(fibonacciCache[naturalNumber]===undefined)){return fibonacciCache[naturalNumber];}var N=fibonacciCache.length;var lastValue=fibonacciCache[N-1];var penultimateValue=fibonacciCache[N-2];var current;for(var i=N;i<=naturalNumber;i++){current=lastValue+penultimateValue;penultimateValue=lastValue;lastValue=current;}return current;}// wrapper for selecting Fibonacci method\nexport function Fibonacci(naturalNumber){// in case the natural number is small we can use memoized version\nif(naturalNumber<MAXIMUM_ARRAY_LENGTH_FOR_MEMOIZATION){return FibonacciIterativeMemoized(naturalNumber);}// if the natural number is big we should use the pure iterative version\n// to prevent filling up the maximum JS Heap Size\nreturn FibonacciIterative(naturalNumber);}","map":{"version":3,"sources":["/home/student/fibo/react-fibonacci-calculator/src/utils/fibonacci.js"],"names":["MAXIMUM_ARRAY_LENGTH_FOR_MEMOIZATION","initialCache","BigInt","fibonacciCache","cleanFibonacciCache","FibonacciIterativeMemoized","naturalNumber","undefined","N","length","i","calc","FibonacciIterative","lastValue","penultimateValue","current","Fibonacci"],"mappings":"AAAA;AACA,mB,CAEA;AACA;AACA,MAAO,IAAMA,CAAAA,oCAAoC,CAAG,KAA7C,CACP;AACA,MAAO,IAAMC,CAAAA,YAAY,CAAG,CAACC,MAAM,CAAC,CAAD,CAAP,CAAYA,MAAM,CAAC,CAAD,CAAlB,CAAuBA,MAAM,CAAC,CAAD,CAA7B,CAArB,CACP;AACA,MAAO,IAAIC,CAAAA,cAAc,WAAOF,YAAP,CAAlB,CAEP,MAAO,SAASG,CAAAA,mBAAT,EAA+B,CACpCD,cAAc,WAAOF,YAAP,CAAd,CACD,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAO,SAASI,CAAAA,0BAAT,CAAoCC,aAApC,CAAmD,CACxD;AACA,GAAI,EAAEH,cAAc,CAACG,aAAD,CAAd,GAAkCC,SAApC,CAAJ,CAAoD,CAClD,MAAOJ,CAAAA,cAAc,CAACG,aAAD,CAArB,CACD,CACD,GAAME,CAAAA,CAAC,CAAGL,cAAc,CAACM,MAAzB,CACA,IAAK,GAAIC,CAAAA,CAAC,CAAGF,CAAb,CAAgBE,CAAC,EAAIJ,aAArB,CAAoCI,CAAC,EAArC,CAAyC,CACvC,GAAMC,CAAAA,IAAI,CAAGR,cAAc,CAACO,CAAC,CAAG,CAAL,CAAd,CAAwBP,cAAc,CAACO,CAAC,CAAG,CAAL,CAAnD,CACAP,cAAc,CAACO,CAAD,CAAd,CAAoBC,IAApB,CACD,CACD,MAAOR,CAAAA,cAAc,CAACG,aAAD,CAArB,CACD,CACD,MAAO,SAASM,CAAAA,kBAAT,CAA4BN,aAA5B,CAA2C,CAChD;AACA,GAAI,EAAEH,cAAc,CAACG,aAAD,CAAd,GAAkCC,SAApC,CAAJ,CAAoD,CAClD,MAAOJ,CAAAA,cAAc,CAACG,aAAD,CAArB,CACD,CACD,GAAME,CAAAA,CAAC,CAAGL,cAAc,CAACM,MAAzB,CACA,GAAII,CAAAA,SAAS,CAAGV,cAAc,CAACK,CAAC,CAAG,CAAL,CAA9B,CACA,GAAIM,CAAAA,gBAAgB,CAAGX,cAAc,CAACK,CAAC,CAAG,CAAL,CAArC,CACA,GAAIO,CAAAA,OAAJ,CACA,IAAK,GAAIL,CAAAA,CAAC,CAAGF,CAAb,CAAgBE,CAAC,EAAIJ,aAArB,CAAoCI,CAAC,EAArC,CAAyC,CACvCK,OAAO,CAAGF,SAAS,CAAGC,gBAAtB,CACAA,gBAAgB,CAAGD,SAAnB,CACAA,SAAS,CAAGE,OAAZ,CACD,CAED,MAAOA,CAAAA,OAAP,CACD,CAED;AACA,MAAO,SAASC,CAAAA,SAAT,CAAmBV,aAAnB,CAAkC,CACvC;AACA,GAAIA,aAAa,CAAGN,oCAApB,CAA0D,CACxD,MAAOK,CAAAA,0BAA0B,CAACC,aAAD,CAAjC,CACD,CACD;AACA;AACA,MAAOM,CAAAA,kBAAkB,CAACN,aAAD,CAAzB,CACD","sourcesContent":["// We need to enable JavaScript Built-in BigInt\n/* global BigInt */\n\n// this number can be tweaked to achieve more efficient calculations\n// but should be carefully selected to prevent filling JS maximum heap size\nexport const MAXIMUM_ARRAY_LENGTH_FOR_MEMOIZATION = 10_000;\n// we use BigInt for bigger precision\nexport const initialCache = [BigInt(0), BigInt(1), BigInt(1)];\n// we make a copy to prevent modifying the original cache\nexport let fibonacciCache = [...initialCache];\n\nexport function cleanFibonacciCache() {\n  fibonacciCache = [...initialCache];\n}\n\n//export function FibonacciRecursive(naturalNumber) {\n//  // memoized version of Fibonacci succession\n//  // for big numbers fails because stack size is exceeded\n//  if (fibonacciCache[naturalNumber]) {\n//    return fibonacciCache[naturalNumber];\n//  }\n//  fibonacciCache[naturalNumber] =\n//    FibonacciRecursive(naturalNumber - 1) +\n//    FibonacciRecursive(naturalNumber - 2);\n//  return fibonacciCache[naturalNumber];\n//}\n\nexport function FibonacciIterativeMemoized(naturalNumber) {\n  // iterative version of Fibonacci with memoization\n  if (!(fibonacciCache[naturalNumber] === undefined)) {\n    return fibonacciCache[naturalNumber];\n  }\n  const N = fibonacciCache.length;\n  for (let i = N; i <= naturalNumber; i++) {\n    const calc = fibonacciCache[i - 1] + fibonacciCache[i - 2];\n    fibonacciCache[i] = calc;\n  }\n  return fibonacciCache[naturalNumber];\n}\nexport function FibonacciIterative(naturalNumber) {\n  // iterative version of Fibonacci using already done calculations\n  if (!(fibonacciCache[naturalNumber] === undefined)) {\n    return fibonacciCache[naturalNumber];\n  }\n  const N = fibonacciCache.length;\n  let lastValue = fibonacciCache[N - 1];\n  let penultimateValue = fibonacciCache[N - 2];\n  let current;\n  for (let i = N; i <= naturalNumber; i++) {\n    current = lastValue + penultimateValue;\n    penultimateValue = lastValue;\n    lastValue = current;\n  }\n\n  return current;\n}\n\n// wrapper for selecting Fibonacci method\nexport function Fibonacci(naturalNumber) {\n  // in case the natural number is small we can use memoized version\n  if (naturalNumber < MAXIMUM_ARRAY_LENGTH_FOR_MEMOIZATION) {\n    return FibonacciIterativeMemoized(naturalNumber);\n  }\n  // if the natural number is big we should use the pure iterative version\n  // to prevent filling up the maximum JS Heap Size\n  return FibonacciIterative(naturalNumber);\n}\n"]},"metadata":{},"sourceType":"module"}