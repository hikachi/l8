{"ast":null,"code":"// We need to enable JavaScript Built-in BigInt\n\n/* global BigInt */\n// this number can be tweaked to achieve more efficient calculations\n// but should be carefully selected to prevent filling JS maximum heap size\nexport const MAXIMUM_ARRAY_LENGTH_FOR_MEMOIZATION = 10000; // we use BigInt for bigger precision\n\nexport const initialCache = [BigInt(0), BigInt(1), BigInt(1)]; // we make a copy to prevent modifying the original cache\n\nexport let fibonacciCache = [...initialCache];\nexport function cleanFibonacciCache() {\n  fibonacciCache = [...initialCache];\n} //export function FibonacciRecursive(naturalNumber) {\n//  // memoized version of Fibonacci succession\n//  // for big numbers fails because stack size is exceeded\n//  if (fibonacciCache[naturalNumber]) {\n//    return fibonacciCache[naturalNumber];\n//  }\n//  fibonacciCache[naturalNumber] =\n//    FibonacciRecursive(naturalNumber - 1) +\n//    FibonacciRecursive(naturalNumber - 2);\n//  return fibonacciCache[naturalNumber];\n//}\n\nexport function FibonacciIterativeMemoized(naturalNumber) {\n  // iterative version of Fibonacci with memoization\n  if (!(fibonacciCache[naturalNumber] === undefined)) {\n    return fibonacciCache[naturalNumber];\n  }\n\n  const N = fibonacciCache.length;\n\n  for (let i = N; i <= naturalNumber; i++) {\n    const calc = fibonacciCache[i - 1] + fibonacciCache[i - 2];\n    fibonacciCache[i] = calc;\n  }\n\n  return fibonacciCache[naturalNumber];\n}\n_c = FibonacciIterativeMemoized;\nexport function FibonacciIterative(naturalNumber) {\n  // iterative version of Fibonacci using already done calculations\n  if (!(fibonacciCache[naturalNumber] === undefined)) {\n    return fibonacciCache[naturalNumber];\n  }\n\n  const N = fibonacciCache.length;\n  let lastValue = fibonacciCache[N - 1];\n  let penultimateValue = fibonacciCache[N - 2];\n  let current;\n\n  for (let i = N; i <= naturalNumber; i++) {\n    current = lastValue + penultimateValue;\n    penultimateValue = lastValue;\n    lastValue = current;\n  }\n\n  return current;\n} // wrapper for selecting Fibonacci method\n\n_c2 = FibonacciIterative;\nexport function Fibonacci(naturalNumber) {\n  // in case the natural number is small we can use memoized version\n  if (naturalNumber < MAXIMUM_ARRAY_LENGTH_FOR_MEMOIZATION) {\n    return FibonacciIterativeMemoized(naturalNumber);\n  } // if the natural number is big we should use the pure iterative version\n  // to prevent filling up the maximum JS Heap Size\n\n\n  return FibonacciIterative(naturalNumber);\n}\n_c3 = Fibonacci;\n\nvar _c, _c2, _c3;\n\n$RefreshReg$(_c, \"FibonacciIterativeMemoized\");\n$RefreshReg$(_c2, \"FibonacciIterative\");\n$RefreshReg$(_c3, \"Fibonacci\");","map":{"version":3,"sources":["/home/student/fibo/react-fibonacci-calculator/src/utils/fibonacci.js"],"names":["MAXIMUM_ARRAY_LENGTH_FOR_MEMOIZATION","initialCache","BigInt","fibonacciCache","cleanFibonacciCache","FibonacciIterativeMemoized","naturalNumber","undefined","N","length","i","calc","FibonacciIterative","lastValue","penultimateValue","current","Fibonacci"],"mappings":"AAAA;;AACA;AAEA;AACA;AACA,OAAO,MAAMA,oCAAoC,GAAG,KAA7C,C,CACP;;AACA,OAAO,MAAMC,YAAY,GAAG,CAACC,MAAM,CAAC,CAAD,CAAP,EAAYA,MAAM,CAAC,CAAD,CAAlB,EAAuBA,MAAM,CAAC,CAAD,CAA7B,CAArB,C,CACP;;AACA,OAAO,IAAIC,cAAc,GAAG,CAAC,GAAGF,YAAJ,CAArB;AAEP,OAAO,SAASG,mBAAT,GAA+B;AACpCD,EAAAA,cAAc,GAAG,CAAC,GAAGF,YAAJ,CAAjB;AACD,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASI,0BAAT,CAAoCC,aAApC,EAAmD;AACxD;AACA,MAAI,EAAEH,cAAc,CAACG,aAAD,CAAd,KAAkCC,SAApC,CAAJ,EAAoD;AAClD,WAAOJ,cAAc,CAACG,aAAD,CAArB;AACD;;AACD,QAAME,CAAC,GAAGL,cAAc,CAACM,MAAzB;;AACA,OAAK,IAAIC,CAAC,GAAGF,CAAb,EAAgBE,CAAC,IAAIJ,aAArB,EAAoCI,CAAC,EAArC,EAAyC;AACvC,UAAMC,IAAI,GAAGR,cAAc,CAACO,CAAC,GAAG,CAAL,CAAd,GAAwBP,cAAc,CAACO,CAAC,GAAG,CAAL,CAAnD;AACAP,IAAAA,cAAc,CAACO,CAAD,CAAd,GAAoBC,IAApB;AACD;;AACD,SAAOR,cAAc,CAACG,aAAD,CAArB;AACD;KAXeD,0B;AAYhB,OAAO,SAASO,kBAAT,CAA4BN,aAA5B,EAA2C;AAChD;AACA,MAAI,EAAEH,cAAc,CAACG,aAAD,CAAd,KAAkCC,SAApC,CAAJ,EAAoD;AAClD,WAAOJ,cAAc,CAACG,aAAD,CAArB;AACD;;AACD,QAAME,CAAC,GAAGL,cAAc,CAACM,MAAzB;AACA,MAAII,SAAS,GAAGV,cAAc,CAACK,CAAC,GAAG,CAAL,CAA9B;AACA,MAAIM,gBAAgB,GAAGX,cAAc,CAACK,CAAC,GAAG,CAAL,CAArC;AACA,MAAIO,OAAJ;;AACA,OAAK,IAAIL,CAAC,GAAGF,CAAb,EAAgBE,CAAC,IAAIJ,aAArB,EAAoCI,CAAC,EAArC,EAAyC;AACvCK,IAAAA,OAAO,GAAGF,SAAS,GAAGC,gBAAtB;AACAA,IAAAA,gBAAgB,GAAGD,SAAnB;AACAA,IAAAA,SAAS,GAAGE,OAAZ;AACD;;AAED,SAAOA,OAAP;AACD,C,CAED;;MAlBgBH,kB;AAmBhB,OAAO,SAASI,SAAT,CAAmBV,aAAnB,EAAkC;AACvC;AACA,MAAIA,aAAa,GAAGN,oCAApB,EAA0D;AACxD,WAAOK,0BAA0B,CAACC,aAAD,CAAjC;AACD,GAJsC,CAKvC;AACA;;;AACA,SAAOM,kBAAkB,CAACN,aAAD,CAAzB;AACD;MAReU,S","sourcesContent":["// We need to enable JavaScript Built-in BigInt\n/* global BigInt */\n\n// this number can be tweaked to achieve more efficient calculations\n// but should be carefully selected to prevent filling JS maximum heap size\nexport const MAXIMUM_ARRAY_LENGTH_FOR_MEMOIZATION = 10_000;\n// we use BigInt for bigger precision\nexport const initialCache = [BigInt(0), BigInt(1), BigInt(1)];\n// we make a copy to prevent modifying the original cache\nexport let fibonacciCache = [...initialCache];\n\nexport function cleanFibonacciCache() {\n  fibonacciCache = [...initialCache];\n}\n\n//export function FibonacciRecursive(naturalNumber) {\n//  // memoized version of Fibonacci succession\n//  // for big numbers fails because stack size is exceeded\n//  if (fibonacciCache[naturalNumber]) {\n//    return fibonacciCache[naturalNumber];\n//  }\n//  fibonacciCache[naturalNumber] =\n//    FibonacciRecursive(naturalNumber - 1) +\n//    FibonacciRecursive(naturalNumber - 2);\n//  return fibonacciCache[naturalNumber];\n//}\n\nexport function FibonacciIterativeMemoized(naturalNumber) {\n  // iterative version of Fibonacci with memoization\n  if (!(fibonacciCache[naturalNumber] === undefined)) {\n    return fibonacciCache[naturalNumber];\n  }\n  const N = fibonacciCache.length;\n  for (let i = N; i <= naturalNumber; i++) {\n    const calc = fibonacciCache[i - 1] + fibonacciCache[i - 2];\n    fibonacciCache[i] = calc;\n  }\n  return fibonacciCache[naturalNumber];\n}\nexport function FibonacciIterative(naturalNumber) {\n  // iterative version of Fibonacci using already done calculations\n  if (!(fibonacciCache[naturalNumber] === undefined)) {\n    return fibonacciCache[naturalNumber];\n  }\n  const N = fibonacciCache.length;\n  let lastValue = fibonacciCache[N - 1];\n  let penultimateValue = fibonacciCache[N - 2];\n  let current;\n  for (let i = N; i <= naturalNumber; i++) {\n    current = lastValue + penultimateValue;\n    penultimateValue = lastValue;\n    lastValue = current;\n  }\n\n  return current;\n}\n\n// wrapper for selecting Fibonacci method\nexport function Fibonacci(naturalNumber) {\n  // in case the natural number is small we can use memoized version\n  if (naturalNumber < MAXIMUM_ARRAY_LENGTH_FOR_MEMOIZATION) {\n    return FibonacciIterativeMemoized(naturalNumber);\n  }\n  // if the natural number is big we should use the pure iterative version\n  // to prevent filling up the maximum JS Heap Size\n  return FibonacciIterative(naturalNumber);\n}\n"]},"metadata":{},"sourceType":"module"}